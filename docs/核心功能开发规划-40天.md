# 小航智能辅导系统 - 核心功能开发规划（35天）

## 项目概述

**开发周期**：40天  
**目标**：实现5大核心功能模块  
---

## 五大核心功能模块

### 🎯 功能1：智能问题分解系统（带明确终止规则）
### 🧠 功能2：改进的ISPO思路分析系统（思路部分）
### 🔍 功能3：交互式错误代码分析与纠错
### 📚 功能4：记忆增强与知识漏洞追踪（需要在朝旭知识图谱后进行开发 ）
### 🤖 功能5：智能提示词选择系统（一鸣找的开源项目整合）

---

## 一、核心功能详细设计

### 功能1：智能问题分解系统（带明确终止规则）

#### 功能描述
在现有分解功能基础上，增加明确的分解终止判断规则，避免过度分解或分解不足。

#### 分解终止规则设计

**规则1：代码行数判断**
- 如果子模块预估代码行数 ≤ 10行 → 停止分解
- 如果子模块预估代码行数 > 30行 → 继续分解
- 10-30行之间 → 根据复杂度判断

**规则2：算法复杂度判断**
- 单一操作（赋值、输出、简单计算）→ 停止分解
- 嵌套循环、递归、复杂条件 → 继续分解
- 单层循环或单个if-else → 可选分解

**规则3：知识点数量判断**
- 涉及1个知识点 → 停止分解
- 涉及3个以上知识点 → 继续分解
- 涉及2个知识点 → 根据学生水平判断

**规则4：学生能力评估**
- 学生明确表示"可以写" → 停止分解
- 学生表示"不太理解" → 继续分解
- 学生沉默或犹豫 → 提供示例后再判断

**规则5：分解层级限制**
- 最大分解层级：5层
- 超过5层强制停止，提示"已达到最细粒度"

#### 实现方案

**1. 在LLM提示词中加入判断逻辑**
```
你需要判断每个子模块是否需要继续分解，判断标准：
1. 预估代码行数 ≤ 10行 → needsFurtherDecomposition: false
2. 只涉及单一操作 → needsFurtherDecomposition: false
3. 涉及3个以上知识点 → needsFurtherDecomposition: true
4. 包含嵌套结构 → needsFurtherDecomposition: true
5. 当前层级 ≥ 5 → needsFurtherDecomposition: false
```

**2. 在JSON响应中增加判断依据字段**
```json
{
  "name": "模块名",
  "needsFurtherDecomposition": true/false,
  "decompositionReason": "判断依据说明",
  "estimatedLines": 15,
  "complexity": "medium",
  "knowledgePoints": ["指针", "链表", "递归"]
}
```

**3. 前端交互优化**
- 如果 needsFurtherDecomposition = false，显示"✅ 已达最细粒度"
- 如果 needsFurtherDecomposition = true，显示"继续分解"按钮
- 显示判断依据，让学生理解为什么需要/不需要分解

#### 开发时间：2天
#### 负责人：张国梁

---

### 核心功能2：改进的ISPO思路分析系统

#### 功能描述
将原有的简单思路分析升级为结构化的ISPO分析框架。

#### ISPO框架设计

**I - Input（输入分析）**
- 从问题中抽象出需要存储的处理对象
- 识别输入数据的特征和约束
- 例如：学生信息、成绩数组、链表节点等

**S - Storage（存储建议）**
- 针对I中的处理对象，建议使用的数据类型
- 提供多种选择，不给出确定性答案
- 例如："学生信息可以用结构体或类来存储"

**P - Process（处理分析）**
- 涉及的相关知识点
- 可能用到的算法
- 不给出具体实现步骤
- 例如："需要用到排序算法，可以考虑冒泡、快排或归并"

**O - Output（输出注意事项）**
- 输出格式要求
- 边界情况处理
- 性能考虑
- 例如："注意处理空数组的情况，输出需要保留两位小数"

#### 实现示例

```
问题：实现学生成绩管理系统

【I - 输入分析】
从问题中我们需要处理以下对象：
- 学生个人信息（姓名、学号）
- 成绩数据（多门课程的分数）
- 查询条件（按姓名或学号查找）

【S - 存储建议】
针对这些对象，你可以考虑：
- 学生信息：可以用结构体（struct）来组织相关数据
- 成绩数据：可以用数组存储多门成绩，或者用链表动态管理
- 整体数据：可以用结构体数组，或者链表来存储多个学生

【P - 处理分析】
这个问题涉及的知识点：
- 数据结构：结构体、数组或链表
- 算法：查找算法（顺序查找或二分查找）
- 可能需要：排序算法（如果要按成绩排序）

【O - 输出注意事项】
- 查找不到学生时，需要给出友好提示
- 成绩显示可能需要格式化（保留小数位）
- 考虑输出的可读性（对齐、表格形式）
```

#### 提示词设计要点
1. **禁止给出确定性方案**："你可以考虑..."、"建议使用..."
2. **提供多种选择**：至少给出2-3种数据结构选择
3. **引导思考**：每个部分后面加上启发性问题
4. **保持开放性**：不限制学生的创造力

#### 开发时间：3-5天
#### 负责人：张国梁

---

### 核心功能3：深度代码分析与思路纠错系统

#### 功能描述
当用户提交代码时，系统不仅检查语法错误，更重要的是**分析解题思路是否正确**，指出思维误区，引导正确的解题方向。

#### 三层分析架构

**第一层：语法层面分析**（基础）
- 编译错误检测
- 语法规范检查
- 代码风格问题

**第二层：逻辑层面分析**（重要）
- 算法逻辑错误
- 边界条件遗漏
- 数据结构使用不当
- 时间/空间复杂度问题

**第三层：思路层面分析**（核心）⭐
- **解题思路是否正确**
- **算法选择是否合理**
- **数据结构选择是否恰当**
- **是否理解题目本质**
- **是否考虑了所有情况**

#### 核心功能点

**3.1 题目理解度分析**
系统首先分析：学生是否真正理解了题目要求？

```
分析维度：
1. 输入理解：学生是否正确识别了输入数据的特征？
2. 输出理解：学生是否明白需要输出什么？
3. 约束理解：学生是否注意到题目的限制条件？
4. 核心问题：学生是否抓住了问题的本质？

示例：
题目：找出数组中第K大的元素
学生代码：直接遍历K次找最大值

思路问题诊断：
❌ 学生理解了"第K大"的含义
✅ 但没有考虑到可以用更高效的算法
💡 建议：这个问题可以用堆、快速选择等方法优化
```

**3.2 算法选择分析**
分析学生选择的算法是否适合这个问题

```
分析维度：
1. 算法正确性：选择的算法能否解决问题？
2. 算法效率：是否是最优解？
3. 算法适用性：是否考虑了数据规模？

示例：
题目：判断链表是否有环
学生代码：用数组存储所有访问过的节点

思路问题诊断：
✅ 算法正确，能检测出环
❌ 但空间复杂度O(n)，不是最优解
💡 思路改进：你知道"快慢指针"方法吗？它只需要O(1)空间
🤔 引导提问：如果链表有100万个节点，你的方法会有什么问题？
```

**3.3 数据结构选择分析**
分析学生选择的数据结构是否合理

```
分析维度：
1. 数据结构适配性：是否匹配问题特征？
2. 操作效率：增删改查的效率如何？
3. 空间利用：是否浪费空间？

示例：
题目：实现一个支持快速查找和插入的电话簿
学生代码：用数组存储，顺序查找

思路问题诊断：
❌ 数据结构选择不当
📊 问题分析：
   - 数组查找：O(n) - 太慢
   - 数组插入：O(n) - 需要移动元素
💡 思路引导：
   - 这个问题的核心是"快速查找"
   - 你学过哪些支持快速查找的数据结构？
   - 哈希表、二叉搜索树都可以考虑
🤔 启发提问：如果有100万条记录，你的方法需要多久？
```

**3.4 边界情况分析**
检查学生是否考虑了特殊情况

```
常见遗漏：
1. 空输入（空数组、空链表、空字符串）
2. 单元素情况
3. 极端值（最大值、最小值、负数、零）
4. 重复元素
5. 数据溢出

示例：
题目：反转链表
学生代码：没有处理空链表的情况

思路问题诊断：
⚠️ 边界情况遗漏
📋 缺失的情况：
   1. 链表为空 → 会导致空指针错误
   2. 只有一个节点 → 虽然能正确处理，但可以优化
💡 思路完善：
   - 在函数开头加上边界检查
   - 思考：还有哪些特殊情况需要处理？
```

**3.5 思维误区识别**
识别学生常见的思维误区

```
常见误区类型：
1. 过度复杂化：简单问题用复杂方法
2. 思维定势：总是用同一种方法
3. 局部优化：只考虑部分情况
4. 忽视约束：没有利用题目给出的条件
5. 效率盲区：不考虑时间/空间复杂度

示例：
题目：判断一个数是否是2的幂次
学生代码：循环除以2，判断最后是否等于1

思路问题诊断：
⚠️ 思维误区：过度复杂化
💡 更简单的思路：
   - 2的幂次有什么特点？
   - 二进制表示只有一个1
   - 可以用位运算：n & (n-1) == 0
🎯 思维启发：
   - 遇到"2的幂次"这类问题，要想到二进制
   - 位运算往往比循环更高效
```

**3.6 交互式思路纠正流程**

```
步骤1：理解题目要求
┌─────────────────────────────────────────────────────────┐
│ � 代题目分析                                              │
├─────────────────────────────────────────────────────────┤
│ 题目：找出数组中第K大的元素                              │
│ 输入：数组 [3,2,1,5,6,4], K=2                           │
│ 期望输出：5                                              │
└─────────────────────────────────────────────────────────┘

步骤2：分析学生代码
┌─────────────────────────────────────────────────────────┐
│ � 你的代码                                               │
├─────────────────────────────────────────────────────────┤
│ 1: int findKthLargest(int arr[], int n, int k) {       │
│ 2:     for(int i=0; i<k; i++) {                        │
│ 3:         int maxIdx = 0;                              │
│ 4:         for(int j=1; j<n; j++) {                    │
│ 5:             if(arr[j] > arr[maxIdx])                │
│ 6:                 maxIdx = j;                          │
│ 7:         }                                            │
│ 8:         arr[maxIdx] = -999999;  // 标记已找到       │
│ 9:     }                                                │
│ 10:    return arr[maxIdx];                              │
│ 11: }                                                   │
└─────────────────────────────────────────────────────────┘

步骤3：三层分析报告
┌─────────────────────────────────────────────────────────┐
│ 📊 深度分析报告                                          │
├─────────────────────────────────────────────────────────┤
│ 【第一层：语法分析】✅ 通过                              │
│ - 没有语法错误                                           │
│ - 代码可以编译                                           │
│                                                         │
│ 【第二层：逻辑分析】⚠️ 发现问题                         │
│ 🟡 问题1：第8行 - 修改原数组                            │
│    - 你用-999999标记已找到的元素                        │
│    - 但如果数组本身包含负数怎么办？                      │
│    - 这会导致错误的结果                                  │
│                                                         │
│ 🟡 问题2：第10行 - 返回值错误                           │
│    - 循环结束后maxIdx是最后一次的值                     │
│    - 但你需要返回第K大的元素                            │
│    - 应该在循环中保存第K大的值                          │
│                                                         │
│ 【第三层：思路分析】❌ 核心问题                          │
│ 🔴 思路问题：算法选择不当                                │
│                                                         │
│ 你的思路：                                               │
│ - 找K次最大值，每次找到后标记为-999999                  │
│ - 时间复杂度：O(K×N)                                    │
│ - 空间复杂度：O(1)                                      │
│                                                         │
│ 思路问题诊断：                                           │
│ ✅ 你理解了"第K大"的含义                                │
│ ✅ 基本思路是可行的                                      │
│ ❌ 但算法效率不高，当K很大时会很慢                       │
│ ❌ 修改原数组不是好的做法                                │
│ ❌ 没有考虑到更优的算法                                  │
│                                                         │
│ 💡 思路改进建议：                                        │
│ 方案1：排序法                                            │
│   - 先对数组排序，然后取第K个                           │
│   - 时间复杂度：O(N log N)                              │
│   - 优点：简单直观                                       │
│   - 缺点：不是最优解                                     │
│                                                         │
│ 方案2：堆（优先队列）                                    │
│   - 维护一个大小为K的小顶堆                             │
│   - 时间复杂度：O(N log K)                              │
│   - 优点：效率高，不修改原数组                          │
│   - 适合：K远小于N的情况                                │
│                                                         │
│ 方案3：快速选择算法                                      │
│   - 类似快速排序的分区思想                              │
│   - 平均时间复杂度：O(N)                                │
│   - 优点：最优解                                         │
│   - 缺点：实现稍复杂                                     │
└─────────────────────────────────────────────────────────┘

步骤4：交互式思路引导
┌─────────────────────────────────────────────────────────┐
│ 🤔 思考题                                                │
├─────────────────────────────────────────────────────────┤
│ AI: 你的算法时间复杂度是O(K×N)，如果K=N/2会怎样？      │
│                                                         │
│ [等待学生回答...]                                        │
│                                                         │
│ 学生: "会变成O(N²)，很慢"                               │
│                                                         │
│ AI: 很好！你意识到了效率问题。那么，你知道有哪些数据    │
│     结构可以快速找到最大/最小值吗？                      │
│                                                         │
│ [等待学生回答...]                                        │
│                                                         │
│ 学生: "堆？"                                             │
│                                                         │
│ AI: 正确！堆可以在O(log K)时间内维护前K大的元素。       │
│     你想试试用堆来实现吗？还是我先给你讲讲堆的思路？     │
│                                                         │
│ [学生选择] [讲解堆的思路] [我自己试试] [看示例代码]     │
└─────────────────────────────────────────────────────────┘

步骤5：思路对比与学习
┌─────────────────────────────────────────────────────────┐
│ 📈 算法对比                                              │
├─────────────────────────────────────────────────────────┤
│ 方法          │ 时间复杂度  │ 空间复杂度 │ 难度 │ 推荐度 │
│ 你的方法      │ O(K×N)     │ O(1)      │ ⭐   │ ⭐⭐   │
│ 排序法        │ O(N log N) │ O(1)      │ ⭐⭐ │ ⭐⭐⭐ │
│ 堆方法        │ O(N log K) │ O(K)      │ ⭐⭐⭐│ ⭐⭐⭐⭐│
│ 快速选择      │ O(N)       │ O(1)      │ ⭐⭐⭐⭐│⭐⭐⭐⭐⭐│
│                                                         │
│ 💡 学习建议：                                            │
│ 1. 先掌握排序法（最简单）                               │
│ 2. 再学习堆方法（实用性强）                             │
│ 3. 最后挑战快速选择（面试常考）                         │
│                                                         │
│ 🎯 知识点关联：                                          │
│ - 这个问题考查：数组、排序、堆、分治                     │
│ - 建议复习：堆的基本操作、快速排序的分区思想            │
└─────────────────────────────────────────────────────────┘
```

#### 技术实现方案

**方案1：题目-代码匹配分析**
```python
def analyze_code_with_problem(problem, student_code):
    """
    将题目和学生代码一起发送给LLM分析
    """
    prompt = f"""
    你是一位经验丰富的算法教师，需要深度分析学生的代码。
    
    【题目】：
    {problem}
    
    【学生代码】：
    {student_code}
    
    请进行三层分析：
    
    1. 【语法层面】：检查语法错误
    2. 【逻辑层面】：检查逻辑错误、边界情况
    3. 【思路层面】（重点）：
       - 学生是否理解了题目要求？
       - 算法选择是否合理？
       - 数据结构选择是否恰当？
       - 时间/空间复杂度如何？
       - 有没有更优的解法？
       - 学生的思维误区在哪里？
    
    输出格式：
    {{
      "syntaxErrors": [...],
      "logicIssues": [...],
      "thoughtAnalysis": {{
        "understanding": "学生对题目的理解程度",
        "algorithmChoice": "算法选择分析",
        "dataStructureChoice": "数据结构选择分析",
        "complexity": "复杂度分析",
        "betterApproaches": ["更优方案1", "更优方案2"],
        "thinkingMistakes": ["思维误区1", "思维误区2"],
        "guidingQuestions": ["引导问题1", "引导问题2"]
      }}
    }}
    """
    
    return llm.analyze(prompt)
```

**方案2：标准答案对比分析**
```python
def compare_with_standard_solution(problem, student_code, standard_solution):
    """
    将学生代码与标准答案对比，找出思路差异
    """
    prompt = f"""
    【题目】：{problem}
    【标准解法】：{standard_solution}
    【学生代码】：{student_code}
    
    请对比分析：
    1. 学生的思路与标准解法有什么不同？
    2. 学生的方法有什么优缺点？
    3. 学生遗漏了哪些关键思路？
    4. 如何引导学生理解标准解法的思想？
    """
    
    return llm.compare(prompt)
```

**方案3：测试用例驱动分析**
```python
def analyze_with_test_cases(problem, student_code, test_cases):
    """
    通过测试用例找出思路问题
    """
    results = []
    
    for test in test_cases:
        result = execute_code(student_code, test['input'])
        
        if result != test['expected']:
            # 分析为什么错误
            analysis = f"""
            测试用例：{test['input']}
            期望输出：{test['expected']}
            实际输出：{result}
            
            请分析：学生的思路在处理这个用例时出了什么问题？
            """
            
            thought_issue = llm.analyze(analysis)
            results.append({
                'test_case': test,
                'thought_issue': thought_issue
            })
    
    return results
```

**方案4：混合方案（推荐）**
```python
def deep_code_analysis(problem, student_code, standard_solution=None):
    """
    综合分析：语法 + 逻辑 + 思路
    """
    # 步骤1：语法检查（编译器）
    syntax_errors = compile_and_check(student_code)
    
    # 步骤2：测试用例验证
    test_results = run_test_cases(student_code, problem.test_cases)
    
    # 步骤3：LLM深度思路分析
    thought_analysis = analyze_code_with_problem(problem, student_code)
    
    # 步骤4：如果有标准答案，进行对比
    if standard_solution:
        comparison = compare_with_standard_solution(
            problem, student_code, standard_solution
        )
    
    # 步骤5：生成综合报告
    return {
        'syntax': syntax_errors,
        'logic': test_results,
        'thought': thought_analysis,
        'comparison': comparison,
        'recommendations': generate_recommendations(thought_analysis)
    }
```

#### 可视化界面设计

**布局：三栏式设计**

```
┌─────────────────────────────────────────────────────────────────┐
│                        顶部：分析概览                            │
│  ✅ 语法正确  ⚠️ 逻辑问题(2)  ❌ 思路问题(1)  💡 优化建议(3)   │
└─────────────────────────────────────────────────────────────────┘
┌──────────────────┬──────────────────┬──────────────────────────┐
│   左栏：题目     │   中栏：代码     │   右栏：分析报告          │
│                  │                  │                          │
│ 📝 题目描述      │ 💻 你的代码      │ 📊 三层分析              │
│                  │                  │                          │
│ 输入：...        │ 1: int find...   │ 【语法层面】✅           │
│ 输出：...        │ 2: for(...)      │                          │
│ 样例：...        │ 3:   ...         │ 【逻辑层面】⚠️          │
│                  │ 4:   ...  ⚠️     │ - 问题1：边界...         │
│ 💡 标准解法      │ 5:   ...         │                          │
│ (可选展开)       │ 6:   ...  ❌     │ 【思路层面】❌          │
│                  │ 7: }             │ 🔴 核心问题：            │
│                  │                  │ 算法选择不当...          │
│                  │ 🎯 复杂度        │                          │
│                  │ 时间：O(K×N)     │ 💡 改进建议：            │
│                  │ 空间：O(1)       │ 1. 排序法...             │
│                  │                  │ 2. 堆方法...             │
│                  │                  │ 3. 快速选择...           │
│                  │                  │                          │
│                  │                  │ 🤔 思考题：              │
│                  │                  │ [交互式引导区域]         │
└──────────────────┴──────────────────┴──────────────────────────┘
┌─────────────────────────────────────────────────────────────────┐
│                    底部：交互式对话区                            │
│  AI: 你的算法时间复杂度是O(K×N)，如果K=N/2会怎样？             │
│  学生: [输入框]                                    [发送]        │
└─────────────────────────────────────────────────────────────────┘
```

**颜色标记系统**
- 🔴 红色：思路层面的核心问题（最重要）
- 🟡 黄色：逻辑层面的警告
- 🔵 蓝色：优化建议
- ✅ 绿色：正确的部分
- 💡 黄色灯泡：改进建议

**交互式元素**
- 点击代码行：显示该行的详细分析
- 点击"更优方案"：展开算法对比
- 点击"思考题"：进入引导式对话
- 点击"查看标准解法"：对比学习

#### 开发时间：15-20天
#### 负责人：张国梁


**基础架构搭建**
- [ ] 设计题目-代码匹配的数据结构
- [ ] 实现代码编译和执行接口
- [ ] 设计三层分析的数据格式
- [ ] 搭建前端三栏布局

**思路分析引擎**（核心）
- [ ] 编写思路分析提示词模板
- [ ] 实现题目理解度分析
- [ ] 实现算法选择分析
- [ ] 实现数据结构选择分析
- [ ] 实现复杂度分析

**：对比与引导系统**
- [ ] 实现标准答案对比功能
- [ ] 实现算法对比表格生成
- [ ] 设计交互式引导问题
- [ ] 实现思维误区识别

**可视化与测试**
- [ ] 完成三栏式界面
- [ ] 实现代码高亮和标记
- [ ] 实现交互式对话
- [ ] 用10个典型题目测试

**特色功能**：
- ✅ 不只纠错，更重要的是纠正思路
- ✅ 算法对比表格，直观展示优劣
- ✅ 交互式引导，启发学生思考
- ✅ 关联知识点，系统性学习

**验收标准**：
- ✅ 能准确识别思路问题
- ✅ 能提供至少2种更优方案
- ✅ 引导问题有启发性
- ✅ 界面清晰，交互流畅

---

### 核心功能4：记忆增强与知识漏洞追踪（在朝旭部分做完之后）

#### 功能描述
通过分析用户的提问、错误代码、学习轨迹，智能识别并存储用户的知识漏洞。

#### 知识漏洞识别维度

**维度1：知识点掌握度**
- 数据结构：数组、链表、栈、队列、树、图
- 算法：排序、查找、递归、动态规划、贪心
- 语法：指针、结构体、文件操作、内存管理

**维度2：错误类型统计**
- 语法错误频率
- 逻辑错误类型
- 常见错误模式

**维度3：学习行为分析**
- 提问频率和质量
- 代码提交次数
- 分解层级深度
- 完成时间

#### 数据存储结构

```json
{
  "userId": "user_123",
  "knowledgeProfile": {
    "dataStructures": {
      "array": {"mastery": 0.8, "errors": 2, "lastPractice": "2025-01-10"},
      "linkedList": {"mastery": 0.4, "errors": 8, "lastPractice": "2025-01-12"},
      "tree": {"mastery": 0.2, "errors": 15, "lastPractice": "2025-01-13"}
    },
    "algorithms": {
      "sorting": {"mastery": 0.7, "errors": 3},
      "recursion": {"mastery": 0.3, "errors": 12}
    },
    "commonErrors": [
      {"type": "pointer", "count": 25, "lastOccurrence": "2025-01-14"},
      {"type": "arrayBounds", "count": 10, "lastOccurrence": "2025-01-13"}
    ]
  },
  "learningPath": [
    {"date": "2025-01-10", "topic": "链表", "result": "struggled"},
    {"date": "2025-01-12", "topic": "递归", "result": "mastered"}
  ],
  "recommendations": [
    "建议加强链表指针操作练习",
    "递归边界条件需要重点关注"
  ]
}
```

#### 智能分析算法

**算法1：知识点掌握度计算**
```
掌握度 = (正确次数 / 总尝试次数) × 0.6 + 
         (1 - 错误率) × 0.3 + 
         时间衰减因子 × 0.1
```

**算法2：知识漏洞优先级排序**
```
优先级 = 重要性权重 × (1 - 掌握度) × 错误频率
```

**算法3：学习路径推荐**
- 基于知识图谱的依赖关系
- 优先推荐前置知识已掌握的内容
- 考虑学习曲线的平滑性

#### 可视化展示

**个人知识图谱**
```
        数据结构
       /    |    \
    数组   链表   树
    ●●●●● ●●○○○ ●○○○○
    (80%)  (40%)  (20%)
```

**学习轨迹时间线**
```
1月10日: 学习链表 → 遇到困难 → 需要加强
1月12日: 学习递归 → 掌握良好 → 可以进阶
1月14日: 综合练习 → 指针错误频繁 → 重点复习
```

#### 费曼学习法集成
- 让学生"教"AI某个知识点
- AI提出刁钻问题测试理解深度
- 根据回答质量评估掌握度

#### 逆图灵测试集成
- AI根据知识漏洞针对性出题
- 动态调整题目难度
- 记录答题表现更新知识图谱

#### 开发时间：7-10天
#### 负责人：王朝旭&张国梁

---

### 核心功能5：智能提示词选择系统

#### 功能描述
根据用户当前状态、历史表现、问题类型，智能选择最合适的提示词策略。

#### 开发时间：2天
#### 负责人：盖一鸣&张国梁

---


