# 代码诊断 — 四种错误划分规则

## 分类原则

按**"错误在什么阶段被发现"**进行分类：

| 阶段 | 错误类型 | 编辑器标记颜色 |
|------|---------|--------------|
| 编译阶段报错 | 语法错误 (Syntax Error) | 🔴 红色 |
| 编译通过但运行时崩溃/异常终止 | 运行时错误 (Runtime Error) | 🟠 橙色 |
| 程序正常运行不崩溃但输出结果不正确 | 逻辑错误 (Logic Error) | 🟡 黄色 |
| 代码写法合法但含义与程序员意图不符 | 语义错误 (Semantic Error) | 🟣 紫色 |

---

## 1️⃣ 语法错误 (Syntax Error)

### 判定标准

编译器/解释器在编译（解析）阶段直接报错，程序根本无法生成可执行文件或无法开始运行。

### 典型特征

违反了语言的语法规则，编译器会给出明确的错误信息和行号。

### 检查要点与示例

**括号/花括号/方括号不匹配：**
```c
if (x > 0 {       // ❌ 缺少右圆括号 )
    printf("ok");
}
```

**缺少必要的分号（C）或冒号（Python）：**
```c
int a = 5          // ❌ 末尾缺少分号 ;
```

**关键字拼写错误：**
```c
retrun 0;          // ❌ return 拼成了 retrun
whlie(1) {}        // ❌ while 拼成了 whlie
```

**字符串/字符引号不闭合：**
```c
printf("hello);    // ❌ 缺少右引号 "
```

**非法的变量声明：**
```c
int 2var = 5;      // ❌ 变量名不能以数字开头
```

**缩进错误（Python）：**
```python
def foo():
print("hi")       # ❌ 缺少缩进
```

**类型声明语法错误：**
```c
int[] a;           // ❌ C语言中应为 int a[]
```

### ⚠️ 以下情况不属于语法错误

| 代码 | 原因 | 实际归类 |
|------|------|---------|
| `scanf("%d", T)` 缺少 `&` | 编译可通过（可能有警告） | 语义错误 |
| `if (a = 1)` 用赋值代替比较 | C语言中语法合法 | 语义错误 |
| `for(i=0; i<=n; i++)` 多循环一次 | 语法合法 | 逻辑错误 |

---

## 2️⃣ 运行时错误 (Runtime Error)

### 判定标准

代码能通过编译，但在运行过程中程序崩溃、异常终止或产生未定义行为，操作系统或运行时环境会报错（如段错误、浮点异常等）。

### 典型特征

程序在某些输入下直接崩溃退出，而非输出错误结果。

### 检查要点与示例

**空指针/野指针解引用 → Segmentation Fault：**
```c
int *p = NULL;
*p = 5;            // ❌ 对空指针解引用，导致段错误
```

**数组越界访问：**
```c
int a[5];
a[10] = 1;         // ❌ 访问了非法内存
```

**除以零 → Floating Point Exception：**
```c
int result = x / 0; // ❌ 除以零导致浮点异常
```

**栈溢出（无终止条件的递归）：**
```c
void f() { f(); }  // ❌ 无限递归导致 Stack Overflow
```

**内存分配失败后未检查：**
```c
int *arr = (int*)malloc(sizeof(int) * n);
arr[0] = 1;        // ❌ 如果 malloc 失败返回 NULL，这里会崩溃
```

**释放后使用 (Use After Free)：**
```c
free(p);
*p = 1;            // ❌ 已释放的内存不能再访问
```

**双重释放 (Double Free)：**
```c
free(p);
free(p);           // ❌ 对同一指针释放两次
```

**格式化字符串与参数不匹配导致崩溃：**
```c
printf("%s", 123); // ❌ 将整数当字符串指针，可能导致崩溃
```

### ⚠️ 以下情况不属于运行时错误

| 情况 | 实际归类 |
|------|---------|
| 程序没有崩溃但输出了错误结果 | 逻辑错误 |
| `scanf("%d", T)` 缺少 `&`（虽然可能导致崩溃，但根因是误解了scanf的参数要求） | 语义错误 |

---

## 3️⃣ 逻辑错误 (Logic Error)

### 判定标准

代码能编译、能运行、不崩溃，但程序的输出结果与题目要求不一致。程序"做了错误的事情"但自己不知道。

### 典型特征

程序正常退出，但答案不对；编译器和运行时都不会报任何错误。

### 检查要点与示例

**循环边界错误 (Off-by-one)：**
```c
for(i = 0; i <= n; i++)   // ❌ 多循环了一次，应为 i < n
```

**条件判断写反：**
```c
if (a < b) {              // ❌ 本意是 a > b，或 && 写成了 ||
```

**变量初始化位置不对：**
```c
for(i = 0; i < n; i++) {
    int sum = 0;           // ❌ sum 放在循环内部，每次被重置为0
    sum += a[i];
}
// 正确做法：int sum = 0; 应放在循环外部
```

**累加器/计数器未正确更新：**
```c
for(i = 0; i < n; i++) {
    if (a[i] > 0) {
        // ❌ 忘记写 count++;
    }
}
```

**过早返回：**
```c
for(i = 0; i < n; i++) {
    if (a[i] == target)
        return 1;
    return 0;              // ❌ 只检查了第一个元素就返回了
}
```

**算法思路与题目要求不匹配：**
```c
// 题目要求逆序输出，但代码正序输出
for(i = 0; i < n; i++)    // ❌ 应该是 for(i = n-1; i >= 0; i--)
    printf("%d ", a[i]);
```

**边界条件遗漏：**
```c
// ❌ 未处理空输入、单元素、最大值等特殊情况
```

**状态更新顺序错误：**
```c
// ❌ 先修改了 capacity 再 realloc，失败时状态不一致
stack->capacity *= 2;
stack->data = realloc(stack->data, stack->capacity * sizeof(int));
```

**重复操作：**
```c
// ❌ 函数内部已打印了结果，调用处又打印一次
void printResult(int x) {
    printf("%d\n", x);
}
printf("%d\n", printResult(result));  // 打印了两次
```

### 💡 关键理解

逻辑错误关注的是"结果不对"，而非"写法不对"。如果一个错误既导致结果不对，又涉及对语言特性的误解，应同时在逻辑错误和语义错误中指出。

---

## 4️⃣ 语义错误 (Semantic Error)

### 判定标准

代码语法合法、能编译通过，但代码实际表达的含义与程序员的意图不一致。程序员以为代码做的是A，实际做的是B。这类错误往往是逻辑错误的深层根因。

### 典型特征

代码"看起来对"但"意思不对"，通常源于对语言特性、运算符、API的误解。

### 检查要点与示例

**赋值与比较混淆：**
```c
if (a = 1)                 // ❌ 本意是 a == 1 比较，实际是赋值（永远为真）
```

**取地址符遗漏：**
```c
scanf("%d", T);            // ❌ 本意是读入T的值，实际传递的是T的值而非地址 &T
```

**运算符优先级误解：**
```c
a & b == c                 // ❌ 以为是 (a & b) == c，实际是 a & (b == c)
```

**变量作用域误解：**
```c
int x = 10;               // 全局变量
void foo() {
    int x = 20;           // ❌ 以为修改了全局x，实际创建了同名局部变量
}
```

**返回值含义误用：**
```c
if (pop(stack) == -1)      // ❌ 用 -1 表示栈空，但 -1 也可能是栈中的有效元素
```

**浅拷贝与深拷贝混淆：**
```c
int *b = a;                // ❌ 以为复制了数组，实际只复制了指针
```

**类型隐式转换误解：**
```c
int a = 3 / 2;             // ❌ 以为结果是1.5，实际是1（整数除法截断）
```

**指针与数组混淆：**
```c
sizeof(ptr)                // ❌ 以为得到数组长度，实际得到指针大小（4或8字节）
```

**strcmp 返回值误解：**
```c
if (strcmp(s1, s2))        // ❌ 以为返回非0表示相等，实际返回0才表示相等
    printf("相等");
```

---

## 语义错误 vs 逻辑错误 的区别

| 维度 | 逻辑错误 | 语义错误 |
|------|---------|---------|
| 本质 | 算法步骤/流程设计有误 | 对语言特性理解有误 |
| 通俗理解 | "做错了事" | "说错了话" |
| 举例 | 循环多了一次、条件写反 | `=` 和 `==` 混淆、`scanf` 缺 `&` |

**一个问题可以同时涉及两者：** 语义错误是根因，逻辑错误是表现。

例如：`scanf("%d", T)` 缺少 `&`
- 语义错误（根因）：误解了 `scanf` 的参数要求，以为传值即可
- 逻辑错误（表现）：读入的值不正确，导致后续计算结果错误
- 运行时错误（可能后果）：在某些平台上可能导致段错误

此时三个维度都应指出，并注明关联关系。

---

## 诊断输出规范

### 报告格式

每个维度的检查结果：
- 如果存在问题 → 指出具体行号，说明原因，用提问方式引导学生思考
- 如果没有问题 → 标记为 "✅ 未发现问题"

### 编辑器标记 JSON 格式

诊断报告末尾附带 JSON 错误定位块，用于在 Monaco 编辑器中高亮标记错误行：

```
diagnosis-markers
[
  {"type": "syntax",   "startLine": 行号, "endLine": 行号, "message": "错误描述"},
  {"type": "runtime",  "startLine": 行号, "endLine": 行号, "message": "错误描述"},
  {"type": "logic",    "startLine": 起始行号, "endLine": 结束行号, "message": "错误描述"},
  {"type": "semantic", "startLine": 行号, "endLine": 行号, "message": "错误描述"}
]
```

- `type` 只能是: `syntax`, `runtime`, `logic`, `semantic` 四种之一
- `startLine` 和 `endLine` 是学生代码中的行号（从1开始计数）
- 如果错误只涉及一行，`startLine` 和 `endLine` 相同
- 如果所有维度都没有错误，输出空数组 `[]`
