# 代码框架模块 — 分解规则详解

## 一、概述

点击"代码框架"按钮后，系统会将题目按照**"自顶向下、逐步求精"**的结构化程序设计方法，将一个完整问题分解为多个子模块。每个子模块用 **ISPO 模型**描述，并标注控制结构类型，最终以可交互的卡片形式呈现。

以"实现栈的基本操作"为例，系统会生成如下结构：

```
实现栈的基本操作（📋 顺序结构）
├── 📋 初始化栈
├── 🔀 入栈操作
├── 🔀 出栈操作
├── 🔀 查询栈顶元素
├── 📥 输入操作的总数 T 和 T 个操作命令
├── 💾 存储（栈结构体）
├── ⚙️ 处理（解析并执行每个操作命令）
└── 📤 输出（栈顶元素或 'Stack is empty'）
```

---

## 二、核心模型：ISPO

系统采用 **ISPO 模型**（而非传统的 IPO），每个模块必须包含四个维度：

| 维度 | 含义 | 图标 | 颜色标识 |
|------|------|------|---------|
| **I** - Input（输入） | 该模块需要什么输入数据 | 📥 | 蓝色 |
| **S** - Storage（存储） | 建议使用什么数据结构或变量来存储数据 | 💾 | 紫色 |
| **P** - Process（处理） | 如何处理数据 | ⚙️ | 黄色 |
| **O** - Output（输出） | 产生什么输出 | 📤 | 绿色 |

**Storage 是 ISPO 区别于 IPO 的关键字段**，它引导学生在编码前先思考"用什么数据结构来存储数据"。

### 以"实现栈的基本操作"为例的整体 ISPO：

| 维度 | 内容 |
|------|------|
| **I（输入）** | 操作的总数 T 和 T 个操作命令（push x / pop / top） |
| **S（存储）** | 需要一个栈结构体来管理栈的数据，包括一个整型数组存储栈中元素，一个整型变量记录栈的容量，一个整型变量记录栈顶指针 |
| **P（处理）** | 初始化栈，读取并解析每个操作命令，根据命令执行相应的栈操作（入栈、出栈、查询栈顶元素），最后释放栈占用的内存 |
| **O（输出）** | 对于每个 `top` 操作，输出栈顶元素；如果栈为空，输出 'Stack is empty' |

---

## 三、控制结构分类

每个子模块必须标注其控制结构类型，系统只有三种基本控制结构：

| 类型 | 图标 | 含义 | 适用场景 |
|------|------|------|---------|
| **sequence**（顺序结构） | 📋 | 按顺序执行 | 变量声明、赋值、函数调用、输入输出 |
| **selection**（选择结构） | 🔀 | 条件分支 | if-else、switch 判断 |
| **loop**（循环结构） | 🔄 | 重复执行 | for、while、do-while 循环 |

### 以"实现栈的基本操作"为例的控制结构标注：

| 子模块 | 控制结构 | 原因 |
|--------|---------|------|
| 初始化栈 | 📋 顺序 | 声明结构体、分配内存、设置初始值，都是顺序执行 |
| 入栈操作 | 🔀 选择 | 需要判断栈是否已满，满则扩容，否则直接入栈 |
| 出栈操作 | 🔀 选择 | 需要判断栈是否为空，空则报错，否则弹出元素 |
| 查询栈顶元素 | 🔀 选择 | 需要判断栈是否为空，空则输出提示，否则返回栈顶 |
| 读取并执行 T 个操作 | 🔄 循环 | 需要循环 T 次，每次读取一个命令并执行 |

---

## 四、分解规则

### 4.1 分解的核心原则

1. **自顶向下**：从整体问题出发，逐层细化
2. **分而治之**：将复杂问题分解成更小、更简单的子模块
3. **每层 2-4 个子模块**：不宜过多（难以理解）也不宜过少（分解不充分）
4. **基于标准答案的代码结构**：分解出的模块与标准答案的实现结构一致
5. **与前置模块保持一致**：框架是思路和伪代码的结构化表达

### 4.2 分解粒度判断标准

每个子模块都会被判断是否"足够简单"（`needsFurtherDecomposition`），决定学生是直接写代码还是继续分解。

**足够简单（needsFurtherDecomposition = false）的标准：**

| 维度 | 标准 |
|------|------|
| 代码行数 | ≤ 5 行有效代码即可实现 |
| 控制结构 | 只有单一控制结构（纯顺序 / 单层条件 / 单层循环） |
| 变量数量 | 涉及 ≤ 3 个变量 |

简单模块示例：
- 声明整型变量并初始化累加器
- 使用格式化输入/输出读取或打印数据
- 通过条件判断比较两个值的大小关系
- 使用循环结构遍历数组元素并逐个累加
- 对栈/队列执行一次基本操作（如入栈、出栈）

**需要继续分解（needsFurtherDecomposition = true）的标准：**

| 维度 | 标准 |
|------|------|
| 嵌套结构 | 循环嵌套、条件嵌套、循环+条件嵌套 |
| 多步骤处理 | 需要先A再B再C的连续操作 |
| 复杂数据操作 | 涉及多个指针、多次遍历 |
| 算法核心逻辑 | 排序、查找、递归的核心部分 |
| 边界处理复杂 | 需要考虑多种边界情况 |

复杂模块示例：
- 嵌套循环（如冒泡排序的双重循环）
- 递归调用（如二叉树遍历）
- 多指针操作（如链表反转）
- 完整的排序/查找算法

---

## 五、分解的提示词设计

### 5.1 第一层分解（点击"代码框架"按钮触发）

系统向 LLM 发送的提示词核心要求：

```
角色：程序设计教学专家
任务：将问题分解为子模块
模型：ISPO（Input → Storage → Process → Output）
输出：JSON 格式，包含 parentProblem、level、subProblems、overallIPO
```

提示词中的关键约束：
1. 分解为 2-4 个子模块
2. 每个模块标注 controlType（sequence / selection / loop）
3. 每个模块的 ipo 必须包含 input、storage、process、output 四个字段
4. storage 字段必须具体说明建议使用的数据结构或变量类型
5. needsFurtherDecomposition 判断是否需要继续分解
6. codeHint 必须是建议性的自然语言描述，禁止给出代码

### 5.2 继续分解（点击"🔍 不能，继续分解"按钮触发）

当学生表示"还不能写出代码"时，系统会对该子模块进行更细粒度的分解：

```
角色：精通"自顶向下、逐步求精"的结构化程序设计方法的教学专家
任务：对当前子模块进行第 N 层分解
目标：让每个子模块简单到学生能直接写出代码
上下文：包含之前的分解历史，确保层次连贯
```

### 5.3 JSON 输出格式

LLM 返回的 JSON 结构如下：

```json
{
    "parentProblem": "问题描述",
    "level": 1,
    "subProblems": [
        {
            "name": "模块名",
            "description": "具体要完成的任务",
            "controlType": "sequence | selection | loop",
            "ipo": {
                "input": "需要什么输入数据",
                "storage": "建议使用什么数据结构/变量来存储",
                "process": "如何处理数据",
                "output": "产生什么输出"
            },
            "needsFurtherDecomposition": true或false,
            "codeHint": "建议性的语句提示（自然语言，禁止代码）"
        }
    ],
    "overallIPO": {
        "input": "总输入",
        "storage": "整体存储结构建议",
        "process": "总处理",
        "output": "总输出"
    }
}
```

---

## 六、以"实现栈的基本操作"为例的完整分解过程

### 第一层分解

**父问题：** 实现栈的基本操作

| 子模块 | 控制结构 | I（输入） | S（存储） | P（处理） | O（输出） | 需要继续分解？ |
|--------|---------|----------|----------|----------|----------|-------------|
| 初始化栈 | 📋 顺序 | 初始容量参数 | 栈结构体（数组+容量+栈顶指针） | 分配内存，设置栈顶为-1 | 初始化完成的栈 | ❌ 否 |
| 读取并执行操作 | 🔄 循环 | 操作总数T和T个命令 | 字符串变量存储命令，整型变量存储操作数 | 循环T次，解析命令并调用对应操作 | 每个操作的执行结果 | ✅ 是 |
| 入栈操作 | 🔀 选择 | 要入栈的元素值 | 栈结构体 | 判断是否需要扩容，将元素放入栈顶 | 更新后的栈 | ❌ 否 |
| 出栈操作 | 🔀 选择 | 当前栈 | 栈结构体 | 判断栈是否为空，移除栈顶元素 | 弹出的元素或错误提示 | ❌ 否 |
| 查询栈顶 | 🔀 选择 | 当前栈 | 栈结构体 | 判断栈是否为空 | 栈顶元素或 'Stack is empty' | ❌ 否 |
| 释放内存 | 📋 顺序 | 栈结构体 | 无 | 释放数组内存，释放结构体 | 无 | ❌ 否 |

### 第二层分解（对"读取并执行操作"继续分解）

学生点击"🔍 不能，继续分解"后：

| 子模块 | 控制结构 | I（输入） | S（存储） | P（处理） | O（输出） |
|--------|---------|----------|----------|----------|----------|
| 读取操作总数 | 📋 顺序 | 标准输入 | 整型变量T | 从输入读取T的值 | T的值 |
| 循环处理每个命令 | 🔄 循环 | T和每次的命令字符串 | 字符串变量存储命令 | 循环T次，每次读取一个命令 | 传递给下一步 |
| 解析并执行命令 | 🔀 选择 | 命令字符串 | 整型变量存储操作数 | 判断是push/pop/top，调用对应函数 | 操作执行结果 |

---

## 七、交互流程

前端以可交互卡片形式呈现分解结果，学生的操作流程如下：

```
查看模块卡片（含 Mermaid 逻辑图 + ISPO 四维信息）
         │
         ▼
   "你能写出这个模块的代码吗？"
         │
    ┌────┴────┐
    ▼         ▼
 ✅ 能      🔍 不能
    │         │
    ▼         ▼
 打开代码   调用后端继续分解
 输入框     生成更细的子卡片
    │         │
    ▼         ▼
 确认完成   重复上述流程
    │
    ▼
 模块标记为绿色 ✅
 进度更新
```

### 关键交互说明：

1. **卡片展开/折叠**：点击卡片头部可以展开或折叠内容
2. **✅ 能，我可以写**：打开代码输入区，学生编写该模块的代码
3. **🔍 不能，继续分解**：调用后端 `/api/xiaohang/decompose_problem` 接口，生成更细粒度的子卡片
4. **确认完成**：模块标记为已完成（绿色），进度计数更新
5. **代码导出**：将所有已编写的模块代码按层级顺序导出到右侧 Monaco 编辑器
6. **全部折叠/展开**：批量操作所有卡片
7. **语句建议**：对于简单模块，可点击"💡 语句建议"查看引导性提示

---

## 八、codeHint（语句建议）的规范

语句建议是对简单模块提供的引导性提示，有严格的规范：

### 必须遵守：
- 使用建议性的自然语言描述
- 用"可以考虑"、"建议"等引导性语气
- 提供多种可能的实现思路，不给唯一方案

### 正确示例：
- "可以考虑使用循环结构（如 for 或 while）来遍历数组元素，逐个累加求和"
- "建议通过条件判断来比较两个数的大小关系，也可以考虑用三元运算的思路"
- "这里需要从标准输入读取数据，可以考虑使用格式化输入的方式"
- "可以考虑对栈/队列执行一次基本操作（如入栈、出栈等）"

### 禁止示例：
- ❌ "使用 for 循环遍历数组"（太确定，没有提及 while 等替代方案）
- ❌ `scanf("%d", &n);`（直接给出代码）
- ❌ `for (int i = 0; i < n; i++) sum += arr[i];`（直接给出代码）

---

## 九、模块间的上下文传递链

代码框架不是孤立的，它处于一个完整的教学链条中：

```
思路（智能审题）→ 框架（代码框架）→ 伪代码 → 核心语句（代码补全）
```

- 框架依赖思路和伪代码的输出
- 框架的分解结构必须与思路中的 ISPO 分析一致
- 框架的模块划分必须与伪代码的逻辑步骤对应
- 后续的核心语句（代码补全）基于框架的模块结构生成 TODO 标记


---

## 十、叶子节点与伪代码/代码补全的一一对应机制

### 10.1 叶子节点的定义

在分解树中，叶子节点是指不再需要继续分解的最终子问题。以用户描述的例子：

```
第0层问题（根）
├── 子问题1（叶子）
├── 子问题2（需要继续分解）
│   ├── 子问题5（叶子）
│   ├── 子问题6（叶子）
│   └── 子问题7（叶子）
├── 子问题3（叶子）
└── 子问题4（叶子）
```

最终的叶子节点按执行顺序为：**1, 5, 6, 7, 3, 4**

### 10.2 一致性保证机制

系统通过以下机制确保叶子节点与伪代码、代码补全的一一对应：

1. **自动同步**：每次分解完成后，前端自动收集所有叶子节点并同步到后端（`/api/xiaohang/save_framework_leaf_nodes`）
2. **叶子节点约束**：生成伪代码和代码补全时，提示词中包含完整的叶子节点列表作为结构约束
3. **手动重新生成**：用户可以点击框架面板中的「🔄 同步到伪代码/补全」按钮，基于当前最终分解结果重新生成伪代码和代码补全（`/api/xiaohang/regenerate_with_leaf_nodes`）

### 10.3 对应关系示例

以上述分解为例，伪代码和代码补全的结构应为：

```
伪代码：
  // 第1部分：子问题1
  ...
  // 第2部分：子问题5
  ...
  // 第3部分：子问题6
  ...
  // 第4部分：子问题7
  ...
  // 第5部分：子问题3
  ...
  // 第6部分：子问题4
  ...

代码补全：
  // === 子问题1 ===
  [代码]
  // === 子问题5 ===
  // TODO: 在这里补全代码
  // === 子问题6 ===
  [代码]
  // === 子问题7 ===
  // TODO: 在这里补全代码
  // === 子问题3 ===
  [代码]
  // === 子问题4 ===
  [代码]
```

### 10.4 使用流程

1. 用户点击「智能审题」→ 系统预生成框架、伪代码、代码补全（基于初始分解的叶子节点）
2. 用户在框架面板中对复杂模块点击「🔍 继续分解」→ 系统自动同步新的叶子节点
3. 分解完成后，用户点击「🔄 同步到伪代码/补全」→ 系统基于最终叶子节点重新生成伪代码和代码补全
4. 重新生成的伪代码和代码补全与最终叶子节点严格一一对应
